<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title> ì§±êµ¬ ë˜¥í”¼í•˜ê¸° </title>
<style>
  body {
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #0b0b10;
    color: #fff;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  }
  h2 {
    margin-top: 14px;
    font-size: 20px;
  }
  canvas {
    margin-top: 10px;
    background: radial-gradient(circle at top, #4d8cff 0, #1b2735 45%, #050608 100%);
    border-radius: 12px;
    border: 2px solid #ffffff33;
    box-shadow: 0 12px 30px rgba(0,0,0,0.8);
    touch-action: none;
  }
  #restart {
    margin-top: 12px;
    padding: 8px 16px;
    font-size: 15px;
    border-radius: 999px;
    border: none;
    cursor: pointer;
    display: none;
    background: linear-gradient(135deg, #ff7b7b, #ffb347);
    color: #111;
    font-weight: 600;
    box-shadow: 0 6px 18px rgba(0,0,0,0.5);
  }
  #restart:active {
    transform: translateY(1px);
    box-shadow: 0 3px 10px rgba(0,0,0,0.4);
  }
  #tip {
    margin-top: 8px;
    font-size: 13px;
    opacity: 0.8;
    text-align: center;
    line-height: 1.4;
  }
</style>
</head>
<body>

<h2>ğŸ’© ë˜¥í”¼í•˜ê¸° â€“ ì§±êµ¬ ë²„ì „</h2>
<canvas id="game" width="400" height="600"></canvas>
<button id="restart">ë‹¤ì‹œ ì‹œì‘</button>
<div id="tip">
  â† â†’ / A D í‚¤ ë˜ëŠ” í™”ë©´ ì¢Œìš° í„°ì¹˜<br/>
  â­ ë…¸ë€ ë³„ = ë¬´ì  / íŒŒë€ ì•Œì•½ = ìŠ¬ë¡œìš°
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const restartBtn = document.getElementById("restart");

function loadSprite(src) {
  const img = new Image();
  img.src = src;
  return img;
}

// ---- ì˜¤ë””ì˜¤ (BGM) ----
let bgmStarted = false;
let bgm;
try {
  bgm = new Audio("bgm.mp3");
  bgm.loop = true;
} catch (e) {
  bgm = null;
}

function tryStartBgm() {
  if (!bgm || bgmStarted) return;
  bgmStarted = true;
  bgm.volume = 0.7;
  bgm.play().catch(() => {
  });
}

// ---- í”Œë ˆì´ì–´ ì´ë¯¸ì§€ ----
const playerImg = new Image();
let playerImgLoaded = false;
playerImg.src = "player.png";
playerImg.onload = () => {
  playerImgLoaded = true;
};

// ---- ê²Œì„ ìƒíƒœ ----
let isGameOver = false;
let lastTime = 0;
let score = 0;
let bestScore = 0;
let timeElapsed = 0;

// í™”ë©´ í”ë“¤ë¦¼(shake)
let shakeTimer = 0;
const SHAKE_DURATION = 0.35;
const SHAKE_MAG = 12;

// íŒŒì›Œì—… ìƒíƒœ
let invincibleTimer = 0;
let slowTimer = 0;

// ê¸€ë¡œë²Œ ì†ë„ ê³„ìˆ˜ (ìŠ¬ë¡œìš° ì•„ì´í…œ)
function getSpeedFactor() {
  return slowTimer > 0 ? 0.45 : 1.0;
}

// í”Œë ˆì´ì–´
const player = {
  x: canvas.width / 2 - 20,
  y: canvas.height - 90,
  w: 50,
  h: 70,
  speed: 260,
  moveDir: 0
};

// ë˜¥ íƒ€ì… 3ì¢…ë¥˜
const POOP_TYPES = [
  { 
    name: "smallFast",
    size: 35,
    color: "#ffc15e",
    speedMin: 230,
    speedMax: 330,
    img: loadSprite("zinsang_circle.png")
  },
  { 
    name: "normal",
    size: 42,
    color: "#9b5b2a",
    speedMin: 170,
    speedMax: 250,
    img: loadSprite("zoongseong_circle.png")
  },
  { 
    name: "bigSlow",
    size: 50,
    color: "#5b3a1a",
    speedMin: 110,
    speedMax: 180,
    img: loadSprite("osu_circle.png")
  }
];

const BG_PHASES = [
  { minScore: 0,   img: loadSprite("bg1.jpg") }, // 0ì  ì´ìƒ
  { minScore: 200, img: loadSprite("bg2.jpg") }, // 200ì  ì´ìƒ
  { minScore: 500, img: loadSprite("bg3.jpg") }, // 500ì  ì´ìƒ
];

const poops = [];
let poopTimer = 0;

// ì•„ì´í…œ (ë¬´ì  / ìŠ¬ë¡œìš°)
const items = [];
let itemTimer = 0;
const ITEM_TYPES = [
  { type: "invincible", color: "#ffd93b" }, // ë…¸ë€ ë³„
  { type: "slow",       color: "#4db8ff" }  // íŒŒë€ ì•Œì•½ ëŠë‚Œ
];

// í‚¤ ì…ë ¥
const keys = {
  left: false,
  right: false
};

// ---- ìœ í‹¸ ----
function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function rectIntersect(a, b) {
  return !(
    a.x + a.w < b.x ||
    a.x > b.x + b.w ||
    a.y + a.h < b.y ||
    a.y > b.y + b.h
  );
}
function getCurrentBg() {
  // scoreëŠ” ì´ë¯¸ ì „ì—­ ë³€ìˆ˜ë¡œ ìˆìœ¼ë‹ˆê¹Œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
  let current = BG_PHASES[0].img;
  for (const phase of BG_PHASES) {
    if (score >= phase.minScore) {
      current = phase.img;
    } else {
      break;
    }
  }
  return current;
}

// ì›-ì‚¬ê°í˜• ì¶©ëŒ (ì•„ì´í…œìš©)
function circleRectCollide(cx, cy, r, rect) {
  const testX = clamp(cx, rect.x, rect.x + rect.w);
  const testY = clamp(cy, rect.y, rect.y + rect.h);
  const distX = cx - testX;
  const distY = cy - testY;
  const distSq = distX * distX + distY * distY;
  return distSq <= r * r;
}

// ---- ë˜¥ ìƒì„± ----
function spawnPoop() {
  // íƒ€ì… ëœë¤, ì•½ê°„ ê°€ì¤‘ì¹˜
  const r = Math.random();
  let t;
  if (r < 0.4) t = POOP_TYPES[1];          // ì¼ë°˜
  else if (r < 0.7) t = POOP_TYPES[0];     // ì‘ì€/ë¹ ë¥¸
  else t = POOP_TYPES[2];                  // í°/ëŠë¦°

  const size = t.size;
  const base = t.speedMin + Math.random() * (t.speedMax - t.speedMin);
  const speed = (base + timeElapsed * 6) * getSpeedFactor();

  poops.push({
    x: Math.random() * (canvas.width - size),
    y: -size - 20,
    w: size,
    h: size,
    color: t.color,
    speed,
    img: t.img
  });
}

// ---- ì•„ì´í…œ ìƒì„± ----
function spawnItem() {
  const it = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
  const radius = 14;
  const speed = (130 + Math.random() * 60) * getSpeedFactor();
  items.push({
    x: Math.random() * (canvas.width - radius * 2) + radius,
    y: -40,
    r: radius,
    type: it.type,
    color: it.color,
    speed
  });
}

// ---- ì…ë ¥ ì²˜ë¦¬ ----
document.addEventListener("keydown", (e) => {
  if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = true;
  if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = true;

  if (!isGameOver) {
    tryStartBgm();
  }

  if (isGameOver && e.code === "Space") restart();
});
document.addEventListener("keyup", (e) => {
  if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = false;
  if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = false;
});

// ëª¨ë°”ì¼ í„°ì¹˜
canvas.addEventListener("touchstart", (e) => {
  tryStartBgm();
  handleTouch(e);
});
canvas.addEventListener("touchmove", (e) => {
  handleTouch(e);
});
canvas.addEventListener("touchend", () => {
  keys.left = keys.right = false;
});

function handleTouch(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.touches[0].clientX - rect.left;
  if (x < canvas.width / 2) {
    keys.left = true;
    keys.right = false;
  } else {
    keys.right = true;
    keys.left = false;
  }
}

// ---- ì—…ë°ì´íŠ¸ ----
function update(dt) {
  if (isGameOver) return;

  timeElapsed += dt;
  score = Math.floor(timeElapsed * 15);

  // íŒŒì›Œì—… íƒ€ì´ë¨¸ ê°ì†Œ
  if (invincibleTimer > 0) invincibleTimer -= dt;
  if (slowTimer > 0) slowTimer -= dt;
  if (invincibleTimer < 0) invincibleTimer = 0;
  if (slowTimer < 0) slowTimer = 0;

  // í”ë“¤ë¦¼ íƒ€ì´ë¨¸ ê°ì†Œ
  if (shakeTimer > 0) {
    shakeTimer -= dt;
    if (shakeTimer < 0) shakeTimer = 0;
  }

  // í”Œë ˆì´ì–´ ì´ë™
  player.moveDir = 0;
  if (keys.left) player.moveDir -= 1;
  if (keys.right) player.moveDir += 1;

  player.x += player.moveDir * player.speed * dt;
  player.x = clamp(player.x, 0, canvas.width - player.w);

  // ë˜¥ ìŠ¤í°
  poopTimer -= dt;
  if (poopTimer <= 0) {
    spawnPoop();
    const baseInterval = 0.9;
    const minInterval = 0.25;
    const difficulty = Math.max(minInterval, baseInterval - timeElapsed * 0.02);
    poopTimer = difficulty;
  }

  // ì•„ì´í…œ ìŠ¤í° (3~7ì´ˆ ì‚¬ì´ ëœë¤)
  itemTimer -= dt;
  if (itemTimer <= 0) {
    if (Math.random() < 0.7) { // 70% í™•ë¥ ë¡œ ìŠ¤í°
      spawnItem();
    }
    itemTimer = 3 + Math.random() * 4;
  }

  // ë˜¥ ì´ë™ & ì¶©ëŒ
  for (let i = poops.length - 1; i >= 0; i--) {
    const p = poops[i];
    p.y += p.speed * dt;

    if (p.y > canvas.height + 80) {
      poops.splice(i, 1);
      continue;
    }

    if (rectIntersect(player, p)) {
      if (invincibleTimer > 0) {
        // ë¬´ì  ìƒíƒœì¼ ë• í”¼ê²©ë§Œ ì‚´ì§ ì—°ì¶œí•˜ê³  ë¬´ì‹œ
        shakeTimer = SHAKE_DURATION * 0.6;
        poops.splice(i, 1);
        continue;
      }
      // ì§„ì§œ í”¼ê²©
      isGameOver = true;
      shakeTimer = SHAKE_DURATION;
      bestScore = Math.max(bestScore, score);
      restartBtn.style.display = "inline-block";
      break;
    }
  }

  // ì•„ì´í…œ ì´ë™ & ì¶©ëŒ
  for (let i = items.length - 1; i >= 0; i--) {
    const it = items[i];
    it.y += it.speed * dt;

    if (it.y > canvas.height + 60) {
      items.splice(i, 1);
      continue;
    }

    if (circleRectCollide(it.x, it.y, it.r, player)) {
      // íš¨ê³¼ ì ìš©
      if (it.type === "invincible") {
        invincibleTimer = 4; // 4ì´ˆ ë¬´ì 
      } else if (it.type === "slow") {
        slowTimer = 4;       // 4ì´ˆ ìŠ¬ë¡œìš°
      }
      shakeTimer = SHAKE_DURATION * 0.5;
      items.splice(i, 1);
    }
  }
}

// ---- ê·¸ë¦¬ê¸° ----
function drawBackground() {
  let bg = null;

  // ì•ˆì „í•˜ê²Œ í˜„ì¬ ë°°ê²½ ê°€ì ¸ì˜¤ê¸°
  try {
    bg = getCurrentBg();
  } catch (e) {
    bg = null;
  }

  // ë°°ê²½ ì´ë¯¸ì§€ê°€ ì •ìƒ ë¡œë“œëëŠ”ì§€ ì²´í¬
  const canDrawImage =
    bg &&
    typeof bg === "object" &&
    bg.complete &&
    bg.naturalWidth > 0 &&
    bg.naturalHeight > 0;

  if (canDrawImage) {
    // ì •ìƒ ì´ë¯¸ì§€ â†’ ë°”ë¡œ ë°°ê²½ìœ¼ë¡œ ê·¸ë¦¼
    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  } else {
    // ì´ë¯¸ì§€ ë¡œë”© ì „/ì‹¤íŒ¨ â†’ ê·¸ë¼ë°ì´ì…˜ ë°±ì—… ë°°ê²½
    const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grd.addColorStop(0, "#4d8cff");
    grd.addColorStop(1, "#1b2735");
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // ë°”ë‹¥ ì•ˆê°œ/ê·¸ë¦¼ì (ë¶€ë“œëŸ½ê²Œ ë³´ì´ë„ë¡)
  const fog = ctx.createRadialGradient(
    canvas.width / 2,
    canvas.height,
    40,
    canvas.width / 2,
    canvas.height,
    260
  );
  fog.addColorStop(0, "rgba(0,0,0,0.45)");
  fog.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = fog;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}
function drawPlayer() {
  // ê·¸ë¦¼ì
  ctx.beginPath();
  ctx.ellipse(
    player.x + player.w / 2,
    player.y + player.h + 10,
    player.w * 0.6,
    8,
    0,
    0,
    Math.PI * 2
  );
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fill();

  if (playerImgLoaded) {
    ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
  } else {
    // ê¸°ë³¸ ë„¤ëª¨ ìºë¦­í„°
    ctx.fillStyle = "#ffb347";
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // ë¨¸ë¦¬
    ctx.fillStyle = "#ffe45e";
    ctx.fillRect(player.x, player.y - 12, player.w, 14);

    // ë¨¸ë¦¬ë 
    ctx.fillStyle = "#555";
    ctx.fillRect(player.x, player.y - 4, player.w, 5);
  }

  // ë¬´ì  ìƒíƒœì¼ ë•Œ í…Œë‘ë¦¬/íš¨ê³¼
  if (invincibleTimer > 0) {
    const alpha = 0.6 + 0.4 * Math.sin(performance.now() / 120);
    ctx.strokeStyle = `rgba(255, 217, 59, ${alpha})`;
    ctx.lineWidth = 4;
    ctx.strokeRect(player.x - 4, player.y - 6, player.w + 8, player.h + 12);
  }
}

function drawPoops() {
  for (const p of poops) {
    if (p.img && p.img.complete) {
      // ì´ë¯¸ì§€ ì¤€ë¹„ ì™„ë£Œëœ ê²½ìš°
      ctx.drawImage(p.img, p.x, p.y, p.w, p.h);
    } else {
      // ì´ë¯¸ì§€ ì—†ìœ¼ë©´ ê¸°ì¡´ ì‚¼ê°í˜•ìœ¼ë¡œ ëŒ€ì²´
      ctx.fillStyle = p.color || "#9b5b2a";
      ctx.beginPath();
      ctx.moveTo(p.x + p.w / 2, p.y);
      ctx.lineTo(p.x + p.w, p.y + p.h);
      ctx.lineTo(p.x, p.y + p.h);
      ctx.closePath();
      ctx.fill();
    }
  }
}

function drawItems() {
  for (const it of items) {
    ctx.fillStyle = it.color;
    ctx.beginPath();
    if (it.type === "invincible") {
      // ë³„ ëª¨ì–‘
      const spikes = 5;
      const outer = it.r;
      const inner = it.r * 0.5;
      let rot = Math.PI / 2 * 3;
      let x = it.x;
      let y = it.y;
      ctx.moveTo(x, y - outer);
      for (let i = 0; i < spikes; i++) {
        x = it.x + Math.cos(rot) * outer;
        y = it.y + Math.sin(rot) * outer;
        ctx.lineTo(x, y);
        rot += Math.PI / spikes;

        x = it.x + Math.cos(rot) * inner;
        y = it.y + Math.sin(rot) * inner;
        ctx.lineTo(x, y);
        rot += Math.PI / spikes;
      }
      ctx.lineTo(it.x, it.y - outer);
      ctx.closePath();
      ctx.fill();
    } else {
      // ìº¡ìŠ(ì•Œì•½) ëª¨ì–‘
      ctx.beginPath();
      const w = it.r * 1.8;
      const h = it.r * 2.2;
      const x = it.x - w / 2;
      const y = it.y - h / 2;
      const r = w / 2;
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.fill();
    }
  }
}

function drawUI() {
  // ìƒë‹¨ HUD ë°•ìŠ¤
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(0, 0, canvas.width, 48);

  ctx.font = "16px system-ui, sans-serif";
  ctx.fillStyle = "#ffffff";
  ctx.textBaseline = "middle";

  // Score
  ctx.textAlign = "left";
  ctx.fillText(`Score: ${score}`, 12, 24);

  // Best
  ctx.fillStyle = "#ffd93b";
  ctx.fillText(`Best: ${bestScore}`, 130, 24);

  // ìƒíƒœ í‘œì‹œ
  ctx.textAlign = "right";
  let statusText = "";
  if (invincibleTimer > 0) {
    statusText += "ë¬´ì  ";
  }
  if (slowTimer > 0) {
    statusText += statusText ? "+ ìŠ¬ë¡œìš°" : "ìŠ¬ë¡œìš°";
  }
  if (!statusText) statusText = "Normal";

  ctx.fillStyle = invincibleTimer > 0 ? "#ffd93b" : (slowTimer > 0 ? "#4db8ff" : "#dddddd");
  ctx.fillText(statusText, canvas.width - 10, 24);

  // ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´
  if (isGameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(40, canvas.height / 2 - 80, canvas.width - 80, 160);

    ctx.textAlign = "center";
    ctx.fillStyle = "#ffffff";
    ctx.font = "26px system-ui, sans-serif";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 20);

    ctx.font = "18px system-ui, sans-serif";
    ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 8);
    ctx.fillText(`Best: ${bestScore}`, canvas.width / 2, canvas.height / 2 + 32);
    ctx.font = "14px system-ui, sans-serif";
    ctx.fillText("Space / ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘", canvas.width / 2, canvas.height / 2 + 56);
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let offsetX = 0;
  let offsetY = 0;
  if (shakeTimer > 0) {
    const t = shakeTimer / SHAKE_DURATION;
    const intensity = SHAKE_MAG * t;
    offsetX = (Math.random() * 2 - 1) * intensity;
    offsetY = (Math.random() * 2 - 1) * intensity;
  }

  ctx.save();
  ctx.translate(offsetX, offsetY);

  drawBackground();
  drawPoops();
  drawItems();
  drawPlayer();

  ctx.restore();

  drawUI();
}

// ---- ë©”ì¸ ë£¨í”„ ----
function loop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  update(dt);
  draw();

  requestAnimationFrame(loop);
}

// ---- ì¬ì‹œì‘ ----
function restart() {
  isGameOver = false;
  lastTime = 0;
  score = 0;
  timeElapsed = 0;
  poops.length = 0;
  items.length = 0;
  poopTimer = 0;
  itemTimer = 2;
  invincibleTimer = 0;
  slowTimer = 0;
  shakeTimer = 0;
  player.x = canvas.width / 2 - player.w / 2;
  restartBtn.style.display = "none";
}

restartBtn.addEventListener("click", restart);

// ì´ˆê¸°í™”
itemTimer = 2;
requestAnimationFrame(loop);
</script>
</body>
</html>
